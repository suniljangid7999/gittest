no<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.socgen.sgs.api</groupId>
    <artifactId>dataprovider-plugin</artifactId>
    <version>1.0.18-SNAPSHOT</version>

    <dependencies>
        <!-- Other dependencies -->

        <!-- Remove the old Swagger Codegen dependencies -->
        <!-- <dependency>
            <groupId>io.swagger.codegen.v3</groupId>
            <artifactId>swagger-codegen-maven-plugin</artifactId>
            <version>5.3.0</version>
        </dependency> -->

        <!-- <dependency>
            <groupId>io.swagger</groupId>
            <artifactId>swagger-codegen-maven-plugin</artifactId>
            <version>2.4.43</version>
        </dependency> -->

        <!-- Keep only the OpenAPI Generator dependency -->
        <dependency>
            <groupId>org.openapitools</groupId>
            <artifactId>openapi-generator-maven-plugin</artifactId>
            <version>7.8.8</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.openapitools</groupId>
                <artifactId>openapi-generator-maven-plugin</artifactId>
                <version>7.8.8</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>generate</goal>
                        </goals>
                        <configuration>
                            <inputSpec>${project.basedir}/src/main/resources/openapi.yaml</inputSpec>
                            <outputDir>${project.basedir}/target/generated-sources</outputDir>
                            <generatorName>java</generatorName>
                            <additionalProperties>
                                <useJakartaEE>true</useJakartaEE>
                            </additionalProperties>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

<p>dshcxc</p>
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

@Service
public class ExcelService {

    @Autowired
    private UserDataRepository userDataRepository;

    public void processExcelFile(MultipartFile file) throws Exception {
        InputStream inputStream = file.getInputStream();
        Workbook workbook = new XSSFWorkbook(inputStream);
        Sheet sheet = workbook.getSheetAt(0);

        List<UserData> userDataList = new ArrayList<>();
        for (Row row : sheet) {
            // Skip the header row
            if (row.getRowNum() == 0) {
                continue;
            }

            // Read and validate data
            String name = row.getCell(0).getStringCellValue();
            String email = row.getCell(1).getStringCellValue();
            int age = (int) row.getCell(2).getNumericCellValue();

            if (name == null || email == null || age <= 0) {
                throw new IllegalArgumentException("Invalid data in row " + row.getRowNum());
            }

            UserData userData = new UserData();
            userData.setName(name);
            userData.setEmail(email);
            userData.setAge(age);

            userDataList.add(userData);
        }

        // Save to database
        userDataRepository.saveAll(userDataList);

        workbook.close();
    }
}

                     import org.apache.poi.ss.usermodel.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;

public class ExcelFileProcessor {

    public List<String[]> processExcelFile(MultipartFile file) throws Exception {
        // Validate file
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("File is empty or null.");
        }

        // Validate file type
        String fileContentType = file.getContentType();
        if (!"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet".equals(fileContentType)
                && !"application/vnd.ms-excel".equals(fileContentType)) {
            throw new IllegalArgumentException("Invalid file type. Please upload an Excel file.");
        }

        // Get file bytes and create ByteArrayInputStream
        byte[] fileBytes = file.getBytes();
        ByteArrayInputStream inputStream = new ByteArrayInputStream(fileBytes);

        List<String[]> extractedData = new ArrayList<>();

        // Parse Excel file
        Workbook workbook = WorkbookFactory.create(inputStream);
        Sheet sheet = workbook.getSheetAt(0); // Get the first sheet

        // Iterate through rows, skipping the header row
        for (int i = 1; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            if (row != null) {
                String name = getCellValue(row.getCell(0));  // Assuming "name" is in column 0
                String description = getCellValue(row.getCell(1)); // Assuming "description" is in column 1
                extractedData.add(new String[]{name, description});
            }
        }

        return extractedData;
    }

    private String getCellValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                return String.valueOf(cell.getNumericCellValue());
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            default:
                return "";
        }
    }

    public void displayData(List<String[]> data) {
        System.out.println("Extracted Data:");
        for (String[] row : data) {
            System.out.println("Name: " + row[0] + ", Description: " + row[1]);
        }
    }
}
             import com.opencsv.CSVReader;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class CSVFileProcessor {

    public List<String[]> processCSVFile(MultipartFile file) throws Exception {
        // Validate file
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("File is empty or null.");
        }

        // Validate content type (optional)
        String fileContentType = file.getContentType();
        if (!"text/csv".equals(fileContentType) && !file.getOriginalFilename().endsWith(".csv")) {
            throw new IllegalArgumentException("Invalid file type. Please upload a CSV file.");
        }

        List<String[]> extractedData = new ArrayList<>();

        // Read the file using OpenCSV
        try (InputStreamReader inputStreamReader = new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8);
             CSVReader csvReader = new CSVReader(inputStreamReader)) {

            String[] row;
            boolean isHeader = true;

            // Iterate through the rows
            while ((row = csvReader.readNext()) != null) {
                if (isHeader) {
                    isHeader = false; // Skip the header row
                    continue;
                }
                extractedData.add(row); // Add row to the list
            }
        }

        return extractedData;
    }

    public void displayData(List<String[]> data) {
        System.out.println("Extracted Data:");
        for (String[] row : data) {
            System.out.println("Name: " + row[0] + ", Description: " + row[1]);
        }
    }
}
             import org.apache.poi.ss.usermodel.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Service
public class ExcelService {

    @Autowired
    private EmployeeRepository employeeRepository;

    public String saveEmployeesFromFile(MultipartFile file) {
        List<Employee> employees = new ArrayList<>();

        try {
            // Attempt to read the file as an Excel workbook
            Workbook workbook = WorkbookFactory.create(file.getInputStream());
            Sheet sheet = workbook.getSheetAt(0);

            for (Row row : sheet) {
                if (row.getRowNum() == 0) continue; // Skip header row

                Employee employee = new Employee();

                // Dynamically handle different data types
                employee.setName(getCellValue(row.getCell(0)));
                employee.setDepartment(getCellValue(row.getCell(1)));
                employee.setSalary(Double.parseDouble(getCellValue(row.getCell(2))));

                employees.add(employee);
            }

            workbook.close();

            // Save all valid rows
            employeeRepository.saveAll(employees);
            return "File processed successfully. " + employees.size() + " entries saved.";

        } catch (Exception e) {
            // Catch all exceptions and return a meaningful error message
            return "Failed to process file: " + e.getMessage();
        }
    }

    // Helper method to handle different cell types
    private String getCellValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue().toString();
                }
                return String.valueOf(cell.getNumericCellValue());
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            default:
                return "";
        }
    }
}
                 
                     
